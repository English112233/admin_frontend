<!--报表下载按钮 功能有 1.下载中动画显示 2.打开关闭定时获取下载列表 3.返回获取到的list渲染到弹窗-->
<template>
  <div>
    <el-button class="downLoad-btn downLoading-btn" icon="el-icon-download" :class="classObject" type="primary"
               plain
               @click="dialogShow=true">
      报表下载
      <!--计数-->
      <el-badge :value="downLoadingNum" class="item"
                v-if="downLoadingNum>0"></el-badge>
    </el-button>
    <!--excel下载弹窗-->
    <el-dialog custom-class="downLoad-dialog" title="报表文件下载" :visible.sync="dialogShow"
               width="80">
      <download-list-dialog :list="loadList"/>
    </el-dialog>
  </div>
</template>
<script>
  import DownloadListDialog from './DownloadListDialog' // excel下载弹窗
  import $ from 'jquery'

  let timer // 定时获取下载列表的定时器
  let animateTimer // 下载动画的定时器

  let iconTop = ''

  export default {
    components: { DownloadListDialog },
    props: {
      url: String
    },
    data: function () {
      return {
        LatestItem: '', // 最近的一条下载项
        dialogShow: false, // 是否打开弹窗
        loadList: [],
        downLoadedNum: 0, // 当前下载完成的报表个数
        downLoadingNum: 0, // 当前正在下载的报表(未完成)个数
        curState: '-1', //  button当前状态 定义 -1：待生成 0：生成 1：生成中
        isTime: false // 当前是否为定时器，用于判断是否打开弹窗
      }
    },
    beforeMount: function () {
      this.timingTask() // 初始开启定时任务，获取当前用户下载列表
    },
    mounted () {
      this.getTopVal() // 获取下载图标的top值，用于设置动画
    },
    beforeDestroy: function () { // 销毁实例前，关闭定时器
      this.downLoadAnimate(true) // 关闭下载动画
      timer && clearTimeout(timer)
    },
    computed: {
      classObject: function () {
        return {
          // 'downLoading-btn': this.curState === '1' // 下载中...样式
        }
      },
      isOpenTimerTask () {
        return this.$store.state.downloadFiles.openTimerTask
      }
    },
    watch: {
      isOpenTimerTask (bool) { // 监听计算属性isOpenTimerTask
        // console.log(bool, '监听state里面的内容')
        if (bool) {
          // this.downLoadingNum += 1
          this.downLoadAnimate() // 显示下载动画
          setTimeout(() => { // 延迟一会儿再打开定时器，目的：当下载的表格数据较少时，可以第一次就获取到数据，而不必等到下一个10秒再去获取
            this.timingTask()
            this.$store.commit('changeStateVal', { key: 'openTimerTask', value: false }) // 将openTimerTask设为false
          }, 1000)
        }
      }
    },
    methods: {
      /**
       *  获取下载图标的top值，用于设置动画
       * */
      getTopVal () {
        if (iconTop === '') {
          // 获取下载图标的top值，以此为基准设置动画
          let topV = $('.downLoad-btn .el-icon-download').css('top')
          iconTop = topV ? parseInt(topV.replace(/px/, '')) : 0
        }
      },
      /**
       *  下载中的动画效果
       *  @bool 为true则关闭动画
       * */
      downLoadAnimate: function (bool) { // 下载中...的动画效果
        let dom = $('.downLoading-btn .el-icon-download')
        animateTimer && clearInterval(animateTimer)
        animateTimer = null

        if (!bool) {
          animateTimer = setInterval(() => {
            !dom.length && clearInterval(animateTimer)
            dom.animate({ 'top': iconTop + 2 + 'px' }, 1000, function () {
              dom.css({ 'top': iconTop + 'px' })
            })
          }, 200)
        } else {
          dom && dom.stop(true, true) // 关闭当前正在运行的animate动画
        }
      },
      downNum: function (List) { // 赋值当前下载完成个数,正在下载个数,当前下载状态，返回的list
        let downLoadedNum = 0  // 下载完成的个数
        let downLoadingNum = 0 // 正在下载中的个数
        // let len = List.length
        List.map(item => {
          let sucFlag = parseInt(item.sucFlag) // sucFlag值  0: "处理中" 1: "成功" 2: "未提交" -1: "失败"
          if (sucFlag === 0) {
            downLoadingNum++
          } else if (sucFlag === 1) {
            downLoadedNum++
          }
        })
        if ((List && List[0] && this.LatestItem.fileKey !== List[0].fileKey && parseInt(List[0].sucFlag) === 1) || downLoadedNum > this.downLoadedNum) { // 有新的下载完成项
          this.LatestItem = List[0] // 存储当前最近一条下载数据的信息
          if (this.isTime || this.$store.state.downloadFiles.isSureOpen) { // 只有定时器获取到新的下载项才打开弹窗 或者 没有立即获取到文件时显示弹窗
            this.dialogShow = true // 打开下载弹窗显示列表
            this.$store.commit('changeStateVal', { key: 'isSureOpen', value: false })
          }
        }

        this.curState = downLoadingNum > 0 ? '1' : ''
        this.downLoadedNum = downLoadedNum
        this.downLoadingNum = downLoadingNum
        this.loadList = List // 弹窗list赋值
      },
      judgeFn: function (res) { // 判断是否继续开启获取下载列表的定时器
        if (res.content) {
          this.downNum(res.content)
          if (this.curState === '1') { // 报表生成中
            this.downLoadAnimate() // 显示下载中动画...
            return true
          } else {
            this.downLoadAnimate(true) // 关闭下载中...的动画
            return false
          }
        }
        return false
      },
      timingTask () {  // 定时获取下载列表，判断是否有新的完成项，有则打开弹窗
        let _this = this
        let getList = () => {
          timer && clearTimeout(timer)
          _this.$getJson({
            url: _this.url,
            callback: function (vue, res) {
              // console.log('下载列表获取成功', res)
              if (_this.judgeFn(res)) { // 当前报表还没有全部下载完成,继续获取
                timer = setTimeout(() => {
                  _this.isTime = true
                  getList()
                }, 10000)
              } else {
                _this.isTime = false
              }
            },
            fail: function () { // 当下载列表获取失败则继续获取
              timer = setTimeout(() => {
                _this.isTime = true
                getList()
              }, 10000)
            }
          })
        }
        getList()
      }
    }
  }
</script>

<style>

</style>
